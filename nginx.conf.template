worker_processes auto;
daemon off;

error_log stderr warn;

events {
    use epoll;
    worker_connections 1024;
    multi_accept on;
}


http {
    charset utf-8;
    # EA-2236: Disable access logs
    access_log off;
    default_type application/octet-stream;
    include mime.types;
    sendfile on;
   
    tcp_nodelay on;
    tcp_nopush on;
    keepalive_timeout 30;

#     map_hash_max_size 64;
   map_hash_bucket_size 128;

   map $http_accept $format {
      "~*(text/html|application/xhtml\+xml)"                      "html";
      "~*(application/rdf\+xml|rdf/xml|application/xml|text/xml)" "rdf";
      "~*(application/json)"                                      "json";
      "~*(application/ld\+json)"                                  "jsonld";
      "~*(text/turtle|application/turtle|application/x-turtle)"   "ttl";
      "~*(text/n3|text/rdf\+n3|application/n3)"                   "n3";
      "~*(application/n-triples|application/ntriples|text/nt)"    "nt";
   }

   # makes configuring record-api a lot easier
   map $http_accept $include_apikey {
      "~*(text/html|application/xhtml\+xml)" 0;
      default                                1;
   }

   server {
        listen 80 default_server;
        server_name ${DATA_HOST};
        root /usr/share/nginx/html;
        index index.html;

        # "upstream" servers do not use resolver settings by default (paid option),
        # so we proxy directly to the urls
        set $annotation_api ${ANNOTATION_API_HOST};
        set $entity_api ${ENTITY_API_HOST};
        set $set_api ${SET_API_HOST};
        set $fulltext_api ${FULLTEXT_API_HOST};
        set $presentation_api ${PRESENTATION_API_HOST};
        set $record_api ${RECORD_API_HOST};
        set $entity_portal ${ENTITY_PORTAL_HOST};
        set $record_portal ${RECORD_PORTAL_HOST};
        set $set_portal ${SET_PORTAL_HOST};
        set $root_redirect ${ROOT_REDIRECT_URL};
        set $apikey ${API_KEY};
        set $entity_apikey ${ENTITY_API_KEY};

        resolver ${RESOLVER_SETTINGS};

        add_header Link "<http://creativecommons.org/publicdomain/zero/1.0/>;rel=license";

        # include nginx.conf.d/*.conf;

        # Redirect root
        location / {
            if ($format = "ttl"){
                return 303 https://europeana.ontotext.com/void.ttl;
            }

            # otherwise, forward to pro.europeana.eu/page/linked-open-data unless it's a file
            try_files $uri $uri/ $root_redirect$is_args$args;
        }


        # Used by Kubernetes health checks
        location /nginx-health {
            default_type application/json;
            return 200 '{"status":"healthy"}';
        }


        #####################################
        # CORS                          #
        #####################################
        # Add a rewrite to respond with a 200 SUCCESS on every OPTIONS request.
        if ($request_method = 'OPTIONS') {
            return 200;
        }
        add_header 'Access-Control-Allow-Origin' '*';
        add_header 'Access-Control-Allow-Credentials' 'true';
        add_header 'Access-Control-Allow-Methods' 'POST, GET, OPTIONS, DELETE, PUT, PATCH, HEAD';
        add_header 'Access-Control-Max-Age' '600';
        add_header 'Access-Control-Expose-Headers' 'Location';
        add_header 'Access-Control-Allow-Headers' 'x-requested-with, Content-Type, origin, authorization, accept, client-security-token';


        ########################################
        # Negotiation for Record API           #
        ########################################################################################
        # please note that rewrite needs http(s) or $scheme to not enter into an infinite loop #
        # also, adding "redirect" after a rewrite is not needed, it redirects by defailt       #
        ########################################################################################

        rewrite /(item|aggregation/provider|proxy/provider|aggregation/europeana|proxy/europeana)/(.*) /path/$2;

        location ~ ^\/path\/(?<itemid>.*) {
            # HTML
            if ($format = "html"){
                return 303 $scheme://$record_portal/$itemid;
            }
            # RDF
            if ($format = "rdf"){
                return 303 $scheme://$record_api/$itemid.rdf?wskey=$apikey;
            }
            # JSON
            if ($format = "json"){
                return 303 $scheme://$record_api/$itemid.json?wskey=$apikey;
            }
            # JSON-LD
            if ($format = "jsonld"){
                return 303 $scheme://$record_api/$itemid.jsonld?wskey=$apikey;
            }
            # Turtle
            if ($format = "ttl"){
                return 303 $scheme://$record_api/$itemid.ttl?wskey=$apikey;
            }
            # N3
            if ($format = "n3"){
                return 303 $scheme://$record_api/$itemid.n3?wskey=$apikey;
            }
            # N-Triples
            if ($format = "nt"){
                return 303 $scheme://$record_api/$itemid.nt?wskey=$apikey;
            }
        }

        #####################################
        # Annotations                       #
        #####################################

        rewrite ^/annotation/(.+?)/(.+?)/(.+?)$ $scheme://$presentation_api/$1/$2/anno/$3;
        rewrite ^/annotation/(.*) $scheme://$annotation_api/annotation/$1;


        #####################################
        # Negotiation for OpenSKOS          #
        #####################################

        location ~ /concept/(loc|soundgenres)/ {
            try_files $uri.xml $uri/ index.html;
        }

        #####################################
        # Entities                          #
        #####################################

        location ~ /(agent|place|timespan|organi[s|z]ation)/base/ {
            rewrite /(agent|place|timespan|organization)/base/(.*) $scheme://$host:$server_port/$1/$2  permanent;
        }

        location ~ /concept/\d+/base/ {
            rewrite /concept/(.*)/base $scheme://$host:$server_port/concept/$1  permanent;
        }

        location ~ /concept/\d+ {
            # no Apikey
            if ($include_apikey = 0){
                rewrite /concept/(.+) $scheme://$entity_portal/topic/$1;
            }
            # with Apikey
            if ($include_apikey = 1){
                rewrite /concept/(.*) $scheme://$entity_api/concept/$1?wskey=$entity_apikey;
            }
        }

        location ~ /(agent|place|timespan|organi[s|z]ation)/ {
           # no Apikey
           if ($include_apikey = 0){
               rewrite /agent/(.*) $scheme://$entity_portal/person/$1;
               rewrite /timespan/(.*) $scheme://$entity_portal/time/$1;
               rewrite /organi[s|z]ation/(.*) $scheme://$entity_portal/organization/$1;
           }

           # with Apikey
           if ($include_apikey = 1){
               rewrite /(agent|place|timespan|organi[s|z]ation)/(.*) $scheme://$entity_api/$1/$2?wskey=$entity_apikey;
           }
        }

        #####################################
        # Entities                          #
        #####################################

        location ~ /(agent|place|concept|timespan|organi[s|z]ation)/base/ {
            rewrite /(agent|place|concept|timespan|organization)/base/(.*) $scheme://$host/$1/$2  permanent;
        }

        location ~ /(agent|place|concept|timespan|organi[s|z]ation)/ {
            # no Apikey
            if ($include_apikey = 0){
                rewrite /agent/(.*) $scheme://$entity_portal/person/$1;
                rewrite /concept/(.*) $scheme://$entity_portal/topic/$1;
                rewrite /timespan/(.*) $scheme://$entity_portal/time/$1;
                rewrite /organi[s|z]ation/(.*) $scheme://$entity_portal/organization/$1;
            }

            # with Apikey
            if ($include_apikey = 1){
                rewrite /(agent|place|concept|timespan|organi[s|z]ation)/(.*) $scheme://$entity_api/$1/$2?wskey=$entity_apikey;
            }
        }

        ########################################
        # Sets                                 #
        ########################################

        location ~ /set/ {

            # Pas des clés d'Api
            if ($include_apikey = 0){
                rewrite /set/(.*) $scheme://$set_portal/$1;
            }

            # this ugly hack is required because NGINX does not allow nested/combined conditions
            # see https://ezecodes.wordpress.com/2016/06/30/multiple-if-conditions-in-nginx/

            set $setfmt "set";
            if ($format = "json"){
                set $setfmt "${setfmt}json";
            }
            if ($format = "jsonld"){
                set $setfmt "${setfmt}jsonld";
            }

            # Clé d'Api
            if ($setfmt = "setjson"){
                rewrite /set/(.*) $scheme://$set_api/$1.json?wskey=$entity_apikey;
            }
            if ($setfmt = "setjsonld"){
                rewrite /set/(.*) $scheme://$set_api/$1.jsonld?wskey=$entity_apikey;
            }
        }

        #####################################
        # Fulltext                          #
        #####################################

        location ~ ^/(fulltext|presentation)/ {
            rewrite ^/fulltext/(.+?)/(.+?)/(.+?)$ $scheme://$fulltext_api/$1/$2/$3;
        }

        ########################################
        # Negotiation for VoID and SPARQL      #
        ########################################

        location /.well-known/void/ {
            return 302 https://data-host.eu;
        }

        location /sparql/ {
            return 301 https://sparql.europeana.eu;
        }



        # redirect server error pages to the static page /50x.html
        #
        error_page  500 502 503 504  /50x.html;
        location = /50x.html {
            root  html;
        }

   }

}