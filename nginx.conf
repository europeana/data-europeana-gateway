worker_processes auto;
daemon off;

error_log stderr warn;

events {
    use epoll;
    worker_connections 1024;
    multi_accept on;
}


http {
    charset utf-8;
    # EA-2236: Disable access logs
    access_log off;
    default_type application/octet-stream;
    include mime.types;
    sendfile on;
   
    tcp_nodelay on;
    tcp_nopush on;
    keepalive_timeout 30;

#     map_hash_max_size 64;
   map_hash_bucket_size 128;

   map $http_accept $format {
      "~*(text/html|application/xhtml\+xml)"                      "html";
      "~*(application/rdf\+xml|rdf/xml|application/xml|text/xml)" "rdf";
      "~*(application/json)"                                      "json";
      "~*(application/ld\+json)"                                  "jsonld";
      "~*(text/turtle|application/turtle|application/x-turtle)"   "ttl";
      "~*(text/n3|text/rdf\+n3|application/n3)"                   "n3";
      "~*(application/n-triples|application/ntriples|text/nt)"    "nt";
   }

   # makes configuring record-api a lot easier
   map $http_accept $include_apikey {
      "~*(text/html|application/xhtml\+xml)" 0;
      default                                1;
   }

   server {
        listen 80;
        root /usr/share/nginx/html;
        index index.html;

        # "upstream" servers do not use resolver settings by default (paid option),
        # so we proxy directly to the urls
        set $annotation_api annotation-api.test.eanadev.org;
        set $entity_api entity-api-v2.test.eanadev.org;
        set $set_api set-api.test.eanadev.org;
        set $fulltext_api fulltext-api.test.eanadev.org;
        set $presentation_api iiif-api.test.eanadev.org/presentation;
        set $record_api search-api.test.eanadev.org/record;
        set $entity_portal www.europeana.eu/collections;
        set $record_portal www.europeana.eu/item;
        set $set_portal www.europeana.eu/set;
        set $apikey api2demo;
        set $entity_apikey apidemo;

        set $annotation_api ${ANNOTATION_API_HOST};
        set $entity_api ${ENTITY_API_HOST};
        set $set_api ${SET_API_HOST};
        set $fulltext_api ${FULLTEXT_API_HOST};
        set $presentation_api ${PRESENTATION_API_HOST};
        set $record_api ${RECORD_API_HOST};
        set $entity_portal ${ENTITY_PORTAL_HOST};
        set $record_portal ${RECORD_PORTAL_HOST};
        set $set_portal ${SET_PORTAL_HOST};
        set $apikey ${API_KEY};
        set $entity_apikey ${ENTITY_API_KEY};

        server_name ${DATA_HOST};

        resolver ${RESOLVER_SETTINGS};
        add_header Link "<http://creativecommons.org/publicdomain/zero/1.0/>;rel=license";
        include nginx.conf.d/*.conf;


        # Add a rewrite to respond with a 200 SUCCESS on every OPTIONS request.
        if ($request_method = 'OPTIONS') {
            return 200;
        }

        ########################################
        # Negotiation for Record API           #
        ########################################################################################
        # please note that rewrite needs http(s) or $scheme to not enter into an infinite loop #
        # also, adding "redirect" after a rewrite is not needed, it redirects by defailt       #
        ########################################################################################

        rewrite /(aggregation/provider|proxy/provider|aggregation/europeana|proxy/europeana)/(.*) /path/$2 redirect;

        location /path/ {
            # HTML
            if ($format = "html"){
                rewrite /path/(.*) $scheme://$record_portal/$1;
            }
            # RDF
            if ($format = "rdf"){
                rewrite /path/(.*) $scheme://$record_api/$1.rdf?wskey=$apikey;
            }
            # JSON
            if ($format = "json"){
                rewrite /path/(.*) $scheme://$record_api/$1.json?wskey=$apikey;
            }
            # JSON-LD
            if ($format = "jsonld"){
                rewrite /path/(.*) $scheme://$record_api/$1.jsonld?wskey=$apikey;
            }
            # Turtle
            if ($format = "ttl"){
                rewrite /path/(.*) $scheme://$record_api/$1.ttl?wskey=$apikey;
            }
            # N3
            if ($format = "n3"){
                rewrite /path/(.*) $scheme://$record_api/$1.n3?wskey=$apikey;
            }
            # N-Triples
            if ($format = "nt"){
                rewrite /path/(.*) $scheme://$record_api/$1.nt?wskey=$apikey;
            }
        }


        ########################################
        # Negotiation for OpenSKOS          #
        ########################################

        location ~ /concept/(loc|soundgenres) {
            return 301 $scheme://$host$request_uri.xml;
        }

        ########################################
        # Annotations                       #
        ########################################
        rewrite ^/annotation/(.+?)/(.+?)/(.+?)$ $scheme://$presentation_api/$1/$2/anno/$3;
        rewrite ^/annotation/(.*) $scheme://$annotation_api/annotation/$1;


        ########################################
        # Entities                          #
        ########################################

        location ~ /(agent|place|concept|timespan|organi[s|z]ation)/base/ {
            rewrite /(agent|place|concept|timespan|organization)/base/(.*) $scheme://$host/$1/$2  permanent;
        }

        location ~ /(agent|place|concept|timespan|organi[s|z]ation)/ {
            # no Apikey
            if ($include_apikey = 0){
                rewrite /agent/(.*) $scheme://$entity_portal/person/$1;
                rewrite /concept/(.*) $scheme://$entity_portal/topic/$1;
                rewrite /timespan/(.*) $scheme://$entity_portal/time/$1;
                rewrite /organi[s|z]ation/(.*) $scheme://$entity_portal/organization/$1;
            }

            # with Apikey
            if ($include_apikey = 1){
                rewrite /(agent|place|concept|timespan|organi[s|z]ation)/(.*) $scheme://$entity_api/$1/$2?wskey=$entity_apikey;
            }
        }

        ########################################
        # Sets                                 #
        ########################################

        location ~ /set/ {

            # Pas des clés d'Api
            if ($include_apikey = 0){
                rewrite /set/(.*) $scheme://$set_portal/$1;
            }

            # this ugly hack is required because NGINX does not allow nested/combined conditions
            # see https://ezecodes.wordpress.com/2016/06/30/multiple-if-conditions-in-nginx/

            set $setfmt "set";
            if ($format = "json"){
                set $setfmt "${setfmt}json";
            }
            if ($format = "jsonld"){
                set $setfmt "${setfmt}jsonld";
            }

            # Clé d'Api
            if ($setfmt = "setjson"){
                rewrite /set/(.*) $scheme://$set_api/$1.json?wskey=$entity_apikey;
            }
            if ($setfmt = "setjsonld"){
                rewrite /set/(.*) $scheme://$set_api/$1.jsonld?wskey=$entity_apikey;
            }
        }

        ########################################
        # Fulltext                          #
        ########################################

        location ~ ^/(fulltext|presentation)/ {
            rewrite ^/fulltext/(.+?)/(.+?)/(.+?)$ $scheme://$fulltext_api/$1/$2/$3;
        }

        ########################################
        # Negotiation for VoID and SPARQL      #
        ########################################

        location /.well-known/void/ {
            return 302 https://data-host.eu;
        }

        location /sparql/ {
            return 301 https://sparql.europeana.eu;
        }



        # CHECK THIS, I HAVE NO IDEA WHAT IT IS SUPPOSED TO DO
        # remaining default cases
        location / {
            if ($format = "ttl"){
                return 303 https://europeana.ontotext.com/void.ttl;
            }

            # otherwise, try forwarding them to pro unless it's a file
            try_files $uri https://pro.europeana.eu/page/linked-open-data$is_args$args;
        }

        # redirect server error pages to the static page /50x.html
        #
        error_page  500 502 503 504  /50x.html;
        location = /50x.html {
            root  html;
        }

   }

}